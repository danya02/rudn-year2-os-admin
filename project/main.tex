\documentclass[a4page]{article}
\usepackage[14pt]{extsizes} % для того чтобы задать нестандартный 14-ый размер шрифта
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel} % поддержка русского языка
\usepackage{amsmath}  %  математические символы
\usepackage[left=20mm, top=15mm, right=15mm, bottom=30mm, footskip=15mm]{geometry} % настройки полей документа
\usepackage{indentfirst} % по умалчанию убирается отступ у первого абзаца в секции, это отменяет это.
\usepackage{paralist} % добавить компактные списки (compactitem, compactenum, compactdesc)

\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{url}

\usepackage{float}
\floatstyle{ruled}

\usepackage{csquotes}

\usepackage[
    backend=biber, 
    sorting=nyt,
    bibstyle=gost-numeric,
    citestyle=gost-numeric
]{biblatex}

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
%urlcolor=black,linkcolor=black, anchorcolor=black,
%citecolor=black, menucolor=black, filecolor=black,
]{hyperref}

\addbibresource{sources.bib}

\renewcommand{\baselinestretch}{1.35}

\usepackage{minted}

\begin{document} % начало документа
 
 
% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
\begin{titlepage}

\begin{center}
\hfill \break
\textbf{
\large{РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ}\\
\normalsize{Факультет физико-математических и естественных наук}\\ 
\normalsize{Кафедра прикладной информатики и теории вероятностей}\\
}
\vspace*{\fill}
\Large{\textbf{ДОКЛАД\\ на тему <<Загрузка образов операционных систем>>}}
\\
\underline{\textit{\normalsize{Дисциплина: Основы администрирования операционных систем}}}
\vspace*{\fill}

\end{center}
 
 \begin{flushright}
 Студент: \underline{Генералов Даниил}\\ \vspace{0.5cm}
 Группа: \underline{НПИбд-01-21}
 \end{flushright}
 
 
\begin{center} \textbf{МОСКВА} \\ 2022 г. \end{center}
\thispagestyle{empty} % выключаем отображение номера для этой страницы
 
\end{titlepage}
 % КОНЕЦ ТИТУЛЬНОГО ЛИСТА

\newpage

\tableofcontents

\newpage

\newcommand{\code}[1]{\texttt{#1}}

\section{Введение}

Когда компьютер запущен, он позволяет нам делать очень много интересных вещей.
Однако, чтобы он пришел к этому состоянию, нужно сделать много разных действий.
В этом докладе мы рассмотрим, как именно происходит загрузка операционной системы,
до того момента, когда операционная система готова запускаться сама.

\subsection{Архитектура компьютера}

Существует много разных архитектур компьютеров общего назначения.
Чаще всего эти различия в итоге приходят к различиям в архитектуре процессора.
Компьютер на ARM, например, будет работать по-другому, чем компьютер на x86, 
по-другому чем на MIPS, на PowerPC, на Itanium, на SPARC и т.д.

В целях более простого понимания, мы будем рассматривать компьютер на x86\_64 -- 
это самая популярная архитектура сегодня, и она используется в большинстве
персональных компьютеров.

Одной из других важных архитектур является ARM,
которая используется в мобильных устройствах, таких как смартфоны и планшеты,
а также в некоторых серверах~\cite{web:awsarminst}~\cite{web:awsarmpartners}, миникомпьютерах вроде Raspberry Pi~\cite{web:rpiprocessor},
и новых устройствах от Apple~\cite{enwiki:1114570840}.

Рассматривать архитектуру x86 также познавательно, потому что по мере эволюции
этой архитектуры у дизайнеров всегда была задача сохранить совместимость с
предыдущими версиями, и в результате процесс загрузки операционной системы
отражает историю развития архитектуры.

\subsection{Краткая история x86}

После успеха первого в мире 8-битного микропроцессора 8008,
а также его более популярного преемника 8080,
в 1978 году Intel выпустила процессор Intel 8086 -- их первый 16-битный процессор.

К этому времени уже было написано много кода для 8080,
и Intel решили сделать так, чтобы код ассемблера, написанный для 8080,
был совместим с 8086.
Для этого четыре 16-битных регистра (AX, BX, CX, DX)
каждый был разделен на два 8-битных регистра (AH, AL, BH, BL, CH, CL, DH, DL).

8080 имел возможность обращаться к $2^{16}=65536$ адресам,
и его адресное пространство составляло 64 килобайта.
Одним из улучшений 8086 было увеличение адресного пространства до 1 мегабайта
путем добавления четырех новых адресных линий --
теперь было $2^{20}=1048576$ адресов.
Однако старый код должен был продолжать работать,
поэтому в процессор добавлена необычная схема адресации, называемая \emph{сегментацией}~\cite{enwiki:x86memseg}:

Регистры, которые содержат адрес памяти, имеют ширину 16 бит.
Чтобы получить 20-битный адрес,
берется еще одно 16-битное значение, которое находится в \emph{регистре сегмента}.
Это значение сдвигается на 4 бита влево и складывается с адресом в регистре --
таким образом, получается 20-битный адрес, который относится к реальной памяти.

Например, если мы пытаемся обратиться к адресу \code{0x1337} = \code{0b0001\_0011\_0011\_0111},
когда в регистре сегмента находится значение \code{0x5000} = \code{0b0101\_0000\_0000\_0000},
то реальный адрес равен \code{(0x5000 << 4) + 0x1337} =
\code{0b0101\_0000\_0000\_0000\_0000 + 0b0001\_0011\_0011\_0111} = \code{0b0101\_0001\_0011\_0011\_0111} = \code{0x51337}.

Для команд ассемблера, которые позволяют задавать адрес в виде комбинации сегмента и смещения
используется запись вида \code{segment:offset}.
Например, этот же адрес можно записать как \code{0x5000:0x1337}.
(Из-за традиции, обозначение того, что число записано в шестнадцатеричной системе счисления,
принято писать не префиксом \code{0x}, а постфиксом \code{h} --
на самом деле этот адрес записывается как \code{5000h:1337h}.)



\section{Начальное включение компьютера}

Когда вы нажимаете кнопку включения компьютера,
сначала включается его блок питания.
От блока питания напряжение поступает на материнскую плату,
где ток разделяется на несколько сегментов.
Одна из этих цепей питания -- это цепь питания процессора.
В итоге, через некоторое время процессор получает питание и начинает работать.

Когда процессор включается, он находится в режиме,
в котором он ведет себя, как будто он на самом деле Intel 8086 --
он умеет только обращаться к памяти до 1 Мбайта.
Такой режим называется \emph{Real Mode}~\cite{osdev:real}.

В этом режиме процессор начинает выполнять код, который находится по определенному адресу памяти:
\code{FFFFh:0000h} (равный линейному адресу $0xFFFF0$)
\footnote{На современных машинах этот адрес на самом деле находится по линейному адресу $0xFFFFFFF0$ -- почти в конце области 4Гбайт.
Это значит, что процессор использует код в сегменте памяти выше 1 Мбайта,
находясь при этом в режиме, когда такое не должно быть возможно.
Такое состояние называется \emph{Unreal Mode}.}
Этот адрес называется \emph{вектором сброса} (reset vector).
На материнской плате есть чип (обычно какой-то EEPROM), который отвечает по этому адресу~\cite{osdev:sysinit}.

Можно заметить, что от этого адреса до конца 1 Мбайта памяти
(т.е. до адреса $0xFFFFF$)
находится только 16 байт.
Этого недостаточно для того, чтобы сделать что-либо полезное,
поэтому здесь находится только одна-две инструкции:
безусловный переход на другой адрес, где находится код прошивки.


\subsection{BIOS или UEFI}

На материнской плате есть много разного оборудования,
которое нужно системе для работы:
контроллер памяти, контроллер ввода-вывода, видеокарта и т.д.
Производитель материнской платы должен сделать так, чтобы эти устройства были доступны процессору, когда он загружается.

Ради этого производитель материнской платы предоставляет \emph{прошивку} (firmware) --
программу, которая находится в специальном чипе на материнской плате.
Эта программа должна инициализировать все устройства,
найти операционную систему и передать ей управление загрузкой системы.
Пока ОС не загрузила драйверы для устройств, прошивка должна
также предоставлять интерфейс,
который разработчик ОС может использовать для работы с этими устройствами.

На данный момент существует два основных вида прошивки:
BIOS и UEFI.

BIOS -- это стандарт прошивок, который был разработан в 1980-х годах
для IBM PC, и был принят другими производителями.
Он концептуально легче для понимания, и работает на более низком уровне~\cite{osdev:bios}.
В этом докладе мы будем рассматривать именно его.

UEFI -- это более новый стандарт, который был разработан в 2000-х годах.
Он предоставляет гораздо более высокоуровневый интерфейс для загрузчиков,
что позволяет им делать более сложные вещи.

По сути, UEFI -- это система исполнения EFI-программ~\cite{osdev:uefi}.
EFI-программы по структуре похожи на Windows-программы PE-стандарта (<<.exe-файлы>>)
без таблицы экспортируемых символов.
UEFI ответственна за работу с файловой системой, загрузку и запуск EFI-программ;
они затем могут выполнять действия, которые необходимы для загрузки ОС.
Из-за того, что эти программы написаны на более высоком уровне абстракции,
разработчики могут делать более сложные программы-загрузчики более легко.

UEFI также занимается криптографической проверкой тех EFI-программ,
которые загружает -- это позволяет убедиться, что в загружаемую программу
не внесены изменения.

Из-за того, что UEFI более сложно устроен, его устройство не помогает понимать
то, как именно инициализируется компьютер -- сама прошивка UEFI ответственна за то,
чтобы создать окружение, в котором будут работать EFI-программы.
В целях более глубокого понимания, следовательно, дальше в этом докладе мы будем рассматривать BIOS.

\subsection{Power On Self Test}

Когда начинает выполняться код BIOS, первым делом он делает последовательность действий
по проверке наличия, работоспособности и инициализации компонентов компьютера.
Эти действия называются Power On Self Test (POST).
В это время включается монитор и показывается логотип производителя компьютера.
Здесь же происходит ожидание нажатия клавиши для входа в настройки BIOS.

После того, как POST завершается, BIOS ищет загрузочный диск.
С каждого найденного диска считывается первый сектор -- 512 байт.
Этот сектор называется MBR (Master Boot Record): ожидается, что он содержит
код для начала загрузки ОС.

Содержимое этого сектора записывается по адресу \code{0000h:7C00h} в память.
Затем проверяются последние два байта этого сектора: если они равны \code{55h} и \code{AAh},
то это считается загрузочным диском, и начинается загрузка с него.
Если же BIOS перебрал все диски в системе и не нашел ни одного загрузочного,
то он выводит сообщение об ошибке и останавливает работу.

Если сектор MBR был найден, то BIOS делает переход к адресу \code{0000h:7C00h} --
началу загрузочного сектора.
Там должен находиться код загрузчика -- программы, которая начинает загрузку ОС.
Этот код не может быть больше 510 байт, и на практике последние несколько байтов заняты другими данными о диске,
и на самом деле можно использовать только 446 байт для кода.

446 байт для загрузки ОС -- это мало.
Поэтому задачей этого загрузчика является найти на диске и загрузить в память дальнейший код загрузки ОС.
Обычно этот код использует свои собственные знания об устройстве диска ОС -- например, о том, как устроена
файловая система -- чтобы найти и загрузить в память следующий этап: загрузчик второй стадии.

\subsection{Загрузчик второй стадии}

Загрузчик второй стадии занимается задачами, связанными с инициализацией связанной с ним ОС.
Как результат, он может быть более или менее сложным.
На низком конце спектра сложности, MBR для MS-DOS загружает саму MS-DOS с диска, и 
у нее на самом деле нет загрузчика второй стадии.
Операционная система MS-DOS настолько проста, что ей он просто не нужен.
(Запуск программ MS-DOS также устроен очень просто: содержимое файла загружается в память
на адрес \code{PSP:0100h}, и управление передается на этот адрес.)

На другом конце спектра, загрузчики второй стадии бывают очень сложными.
Например, GRUB -- загрузчик второй стадии, который используется в GNU/Linux -- по сути представляет из себя
мини-ОС: он имеет драйверы для разных файловых систем, может запускать другие загрузчики,
подготавливать initramfs для Linux и многое другое, и он может делать эти действия в любой комбинации
с помощью файлов конфигурации, которые описывают все возможные варианты загрузки.


Следует заметить, что относительная сложность GNU GRUB -- это решение его разработчиков, которое позволило
адаптировать его для большого количества различных систем.
Раньше существовали более простые решения для загрузки даже сложных ядер вроде Linux:
так, LILO -- это загрузчик для Linux, который запускается из окружения MS-DOS,
используя его для удобного подключения к процессу загрузки в первой стадии.

Многие загрузчики используют MS-DOS для удобства управления загрузкой (в частности, для использования драйвера FAT) ---
например, SYSLINUX позволяет создать дискету, которой можно манипулировать с помощью стандартных утилит DOS,
которая содержит код для загрузки ядра.
Однако это не обязательно: например, ISOLINUX (часть проекта Syslinux)
используют, чтобы добавить MBR к ISO-образам (стандарта ISO 9660/El Torito),
чтобы компьютер можно было запустить с CD-ROM или USB-накопителя, содержащего бинарную копию этого ISO-файла.
Этот загрузчик можно встретить практически на всех дистрибутивах Linux, которые используют CD-ROM для установки.


Одна из вещей, которые иногда требуются от загрузчиков -- это позволять пользователю выбрать, какую ОС загрузить.
Для этого загрузчик рисует меню, в котором пользователь может выбрать один из вариантов.
Когда пользователь выбрал вариант, загрузчик должен передать управление выбранному загрузчику --
таким же образом, как это делает BIOS.
Этот процесс называется \emph{chainloading}.
Важным замечанием здесь является то, что каждый загрузчик MBR предполагает,
что он будет загружен в память по точному адресу,
с конкретными значениями регистров и памяти.
Поэтому загрузчик, который дает выбор между несколькими вариантами, должен будет сохранить это состояние для другого загрузчика,
а сам переместить себя в другое место в памяти (традиционно в \code{0060h:0000h}).
После этого можно загрузить другой загрузчик в \code{0000h:7C00h} и передать ему управление.

Если же загрузчик загружает ядро своей собственной ОС, то ему нужно лишь загрузить с диска код ядра
и разместить его в предсказуемом месте в памяти.
Для того, чтобы это было возможно, BIOS предоставляет функции для чтения секторов с диска,
а также записывает в память, с какого диска сейчас происходит загрузка.

После того, как загрузчик загрузил код ядра, он должен подготовить состояние системы для запуска ядра.
Для этого осуществляются еще несколько очень важных действий.

\section{Переход в Protected Mode}

До этого момента мы работали в режиме, в котором процессор ведет себя как 8086.
В частности, можно использовать только 1 Мбайт памяти, только один сегмент (64 Кбайта) для стека,
регистры имеют ширину только 16 бит,
и нет никаких ограничений о том, какие адреса содержат код или данные, и можно ли читать или записывать в них.

Для того, чтобы получить доступ к большему количеству памяти и к этим защитным механизмам,
нужно перейти в режим \emph{Protected Mode}.

Предже чем это сделать, нужно выполнить несколько важных действий.

\subsection{Включение A20}

Из-за особенности схемы адресации памяти, которая была в 8086, у программиста была возможность обращаться
к адресам до (1 Мбайт + 64 Кбайта - 256 байт).
Поскольку на 8086 было всего 20 линий адреса (A0 по A19),
то все адреса выше 1 Мбайт на самом деле относились к нижним адресам.

Некоторые программисты в те времена использовали эту особенность в своих программах,
вместо того чтобы обращаться к этой памяти по ее настоящему адресу.
Однако их новый процессор, Intel 80286, имел возможность обращаться к 16 Мбайтам памяти путем добавления
4 новых линий адреса (A20 по A23).

IBM решила использовать этот процессор в своем новом компьютере IBM PC AT.
Чтобы старые программы, которые зависят от особенности 8086, продолжали работать,
линия A20 была отключена по умолчанию~\cite{osdev:a20}.
Это осуществлалось путем проведения ее через свободный пин на контроллере клавиатуры Intel 8042
\footnote{Если вам кажется, что шина адреса процессора и контроллер клавиатуры никак не связаны --
то вы не одиноки; современникам этого решения тоже казалось, что это странно.
Однако в те времена компьютеры не были настолько стандартизированы, как сейчас,
и никто не ожидал, что это решение будет откликаться даже сейчас, в 2022 году.}.

\subsubsection{Проверить, что A20 еще не включена}
Таким образом, чтобы начать использовать все 16 Мбайт памяти (и выше), нужно включить линию A20.
Но сначала нужно проверить, что она не была уже включена ранее, например, другим загрузчиком или самим BIOS.
Нам нужно проверить, что память по адресу выше 1 Мбайт не зеркалится на нижние адреса.

Сейчас наш код работает в Real Mode, и BIOS недавно загрузил в память MBR с нашего диска.
MBR находится по адресу \code{0000h:7C00h}, и мы знаем, что последние два байта (по адресу \code{0000h:7DEEh} равны \code{55h} и \code{AAh}.
Сначала мы сравниваем эти два байта с теми, что находятся по адресу \code{FFFFh:7E0Eh}
-- это как раз адрес (\code{0000h:7DEEh} + 1 Мбайт).
Если они не равны, то линия A20 уже включена, потому что эта память не зеркалится.

Если же они равны, то нужно проверить, что это не совпадение.
Для этого мы изменяем значение в памяти по \code{0000:7DEEh} --
например, вращаем его на 1 бит.
После этого мы снова сравниваем эти два байта с теми, что находятся по адресу \code{FFFFh:7E0Eh} --
если они оказались снова равны, значит память все-таки зеркалится, и линия A20 нужно включить.

\subsubsection{Включить A20}

Есть несколько сигналов, которые складываются с помощью ИЛИ, чтобы получить сигнал включения A20.
Это значит, что для включения A20 нужно установить хотя бы один из этих сигналов,
но для выключения A20 нужно сбросить каждый из этих сигналов.

\begin{itemize}
    \item 
        Традиционный способ -- это программирование контроллера клавиатуры.
        Чтобы взаимодействовать с ним, у нас есть порт \code{64h}.
        Сначала нужно туда послать команду \code{ADh}, чтобы выключить клавиатуру.
        Затем команда \code{D0h} нужна, чтобы прочитать текущее состояние клавиатуры --
        после отправки этой команды нужно считать из порта \code{60h} один байт.
        В этом байте нужно установить бит 1 (иными словами, нужно сделать \code{OR} с \code{02h}).
        Этот бит как раз отвечает за включение линии A20.
        После этого нужно послать команду \code{D1h}, чтобы записать новое состояние клавиатуры,
        и записать этот байт в порт \code{60h}.
        После этого нужно послать команду \code{AEh}, чтобы включить клавиатуру.

\begin{minted}{asm}

a20wait:
    ; цикл ожидания готовности контроллера клавиатуры для записи
    in al, 64h
    test al, 2
    jnz a20wait
    ret

a20wait2:
    ; цикл ожидания готовности контроллера клавиатуры для чтения
    in al, 64h
    test al, 1
    jnz a20wait2
    ret

cli  ; отключаем прерывания

call a20wait
mov al, ADh
out 64h, al  ; выключаем клавиатуру

call a20wait
mov al, D0h
out 64h, al  ; читаем состояние клавиатуры

call a20wait2
in al, 60h
or al, 02h   ; устанавливаем бит 1 в состоянии клавиатуры

call a20wait
mov bl, D1h
out 64h, bl  ; записываем новое состояние клавиатуры

call a20wait
out 60h, al
mov al, AEh
out 64h, al  ; включаем клавиатуру
call a20wait

sti  ; включаем прерывания
\end{minted}


    \item
        BIOS может иметь функцию, которая включает A20.
        Сначала нужно проверить, что эта функция доступна:
        выполнить прерывание \code{15h}, пока в регистре AX находится значение \code{2403h}.
        Если как результат выполнения этого прерывания не поставлен флаг CY,
        и в регистре AH окажется нулевое значение,
        то функция доступна.
        После этого нужно выполнить прерывание \code{15h}, пока в регистре AX находится значение \code{2402h},
        чтобы проверить текущее состояние A20.
        Если CY=0 и AH=0, то это получилось проверить, и ответ будет лежать в AL.
        Если AL=0, то A20 выключена, и нужно выполнить прерывание
        \code{15h}, пока в регистре AX находится значение \code{2401h} -- 
        это должно включить A20.
        Если это получилось сделать, то опять же, CY=0 и AH=0.

\begin{minted}{asm}
mov     ax,2403h                ; проверить поддержку функции 15h
int     15h
jb      a20_ns                  ; 15h не поддерживается 
cmp     ah,0
jnz     a20_ns                  ; 15h не поддерживается

mov     ax,2402h                ; проверить состояние A20
int     15h
jb      a20_failed              ; не получилось проверить
cmp     ah,0
jnz     a20_failed              ; не получилось проверить

cmp     al,1
jz      a20_activated           ; A20 уже включена

mov     ax,2401h                ; включить A20
int     15h
jb      a20_failed              ; не получилось включить
cmp     ah,0
jnz     a20_failed              ; не получилось включить

a20_activated:                  ; A20 включена
\end{minted}

    \item
        Если ваш чипсет поддерживает опцию \emph{Fast A20}, которая появилась в IBM PC/2,
        то можно воспользоваться ей.
        Для этого нужно считать значение из порта \code{92h} и установить бит 1 в этом значении,
        затем записать это значение обратно в порт \code{92h}.
        Это можно сделать в три инструкции,
        однако рекомендуется проверить, что эта опция уже не включена (проверить бит 1 в порту \code{92h}).
        Также стоит убедиться, что бит 0 не установлен -- это настройка быстрой перезагрузки.
        Наконец, этот метод может быть опасным -- нет надежного способа определить, что на самом деле
        делает этот порт на этом чипсете, и на некоторых чипсетах выполнение этого действия отключает видеокарту~\cite{web:a20pain}.

\begin{minted}{asm}
in      al,92h                  ; считать значение из порта 92h
test    al,2                    ; проверить, что A20 уже включена
jnz     a20_activated           ; если A20 уже включена, не делать этого:
or      al,2                    ; установить бит 1
and     al,0feh                 ; убедиться, что бит 0 не установлен
out     92h,al                  ; записать значение в порт 92h
a20_activated:
\end{minted}

    \item
        Наконец, на некоторых системах доступен порт \code{EEh}, из которого можно прочитать значение, чтобы включить A20,
        и в который можно записать значение, чтобы выключить A20. Значение, которое прочитано из этого порта, не определено.
        Опять же, нет надежного способа определить, что на самом деле делает этот порт на этом чипсете,
        и он может делать что-то совсем не связанное с A20. 

\begin{minted}{asm}
    in     al,EEh  ; включить A20
    in     al,EEh  ; выключить A20
\end{minted}

\end{itemize}

\subsection{Инициализация GDT}

Для того, чтобы работал Protected Mode, нужно указать процессору, какие сегменты памяти используются для каких целей.
Эта информация хранится в \emph{Global Descriptor Table}, или \emph{GDT}.
Прежде чем перейти в Protected Mode, нужно инициализировать GDT и сделать так, чтобы процессор использовал её~\cite{osdev:gdttutorial}.

GDT состоит из записей, каждая из которых описывает один сегмент памяти.
Каждая запись состоит из 8 байтов, их всего 8192.
Первая запись никогда не используется процессором, поэтому её часто используют для хранения указателя на саму GDT.
Внутри этих записей есть адрес начала сегмента, длина сегмента, а также настройки разрешений сегмента 
(например, какому режиму доступен сегмент, какие операции с памятью разрешены, и т.д.).


Остальные сегменты должны быть заданы так, как требует этого наше ядро.
Поскольку мы пишем загрузчик для ОС, мы знаем, как именно ядро хочет видеть сегменты памяти сразу после запуска.
Одновременно с этим мы не знаем, как в итоге ядро будет использовать память.
Наша задача сейчас -- инициализировать самый базовый GDT, который позволит ядру запуститься,
чтобы ядро затем инициализировало свою версию GDT.

Самый простой способ инициализировать GDT -- это сделать два сегмента: один для кода и один для данных,
и эти сегменты будут совпадать друг с другом по размеру.
Затем один из этих двух сегментов будет помечен как исполняемый, а другой -- как читаемый и записываемый.
Если так сделать, то результатом будет, что ядро сможет запуститься, и также сможет менять свою собственную память --
это удобно, потому что мы не знаем, что именно ядро хочет дальше делать.
Если ему не нужна способность менять свой собственный код, то в его новой GDT такой настройки не будет.

После того, как GDT была инициализирована, ее нужно загрузить в регистр GDTR, который указывает на начало таблицы.
Для этого используется инструкция \code{LGDT}.
Если она выполнена в Real Mode, где мы сейчас находимся, то это никак не изменит поведение процессора.
В Protected Mode, однако, это сразу применит изменения.
Поэтому важно убедиться, что сегмент, в котором находится код, который исполняется в данный момент,
был помечен как исполняемый в новой GDT -- иначе следующая инструкция вызовет ошибку \emph{General Protection Fault}.
Если в это время нет записи о том, что делать в этом случае, в таблице прерываний \emph{Interrupt Descriptor Table} (IDT),
или если код, на который эта таблица указывает, также не помечен как исполняемый в новой GDT,
то произойдет \emph{Triple Fault}, который приводит к перезагрузке процессора.

Наконец, последний шаг в инициализации GDT -- это установить регистры сегментов \code{CS}, \code{DS}, \code{SS}.
Эти регистры указывают на запись в GDT, которая описывает сегмент, который будет использоваться для соответствующего типа данных:
в порядке, код, данные, стек.

\subsection{Финальный переход в Protected Mode}

Когда все эти изменения были сделаны, можно сделать переключение на Protected Mode.

Стандартного способа вернуться из Protected Mode обратно в Real Mode нет.
Самый надежный способ это сделать -- это перезагрузить процессор,
предварительно сохранив все необходимые данные в оперативной памяти.
Это можно сделать, например, намеренно вызвав ошибку \emph{Triple Fault},
и это как раз то, как такой переход осуществлялся в IBM PC AT.

Это действие сравнительно сложно, и поэтому современные операционные системы этого не делают.
Однако в таком случае нужно быть полностью уверенным, что вы закончили с Real Mode.
В частности, если вы хотите использовать функции BIOS, то они не работают в Protected Mode,
поэтому нужно завершить все операции с ними до перехода в Protected Mode.

Перед этим финальным действием нужно отключить обработку прерываний, потому что прерывание, полученное в этот момент,
может привести к непредсказуемым последствиям (скорее всего -- в итоге к Triple Fault и перезагрузке).
Это делается с помощью инструкции \code{CLI} (Clear Interrupt Flag).

После этого нужно прочитать регистр CR0 (также известный как MSW, \emph{Machine Status Word}),
и в нем поменять бит PE (Protected Mode Enable) -- самый низкий бит -- на 1~\cite{osdev:protected}.

\begin{minted}{asm}
cli  ; отключить прерывания
lgdt [gdt_ptr]  ; загрузить GDT из указанной памяти
mov eax, cr0
or eax, 1  ; установить бит PE
mov cr0, eax
\end{minted}


Когда это сделано, нужно выполнить длинный безусловный переход с помощью инструкции \code{JMP}.
Этот переход имеет аргумент в виде сегмента и смещения, и
этот сегмент используется не так же, как в Real Mode, а вместо этого указывает на запись в GDT.
Это нужно, чтобы в регистре CS оказалось значение, соответствующее сегменту кода в GDT.
После выполнения этого \code{JMP}, переход в Protected Mode будет завершен,
поэтому этот переход можно использовать, чтобы передать управление ядру ОС.

\section{Дальнейшая загрузка: Long Mode}

Теперь, когда процессор находится в Protected Mode,
и мы исполняем код ядра,
мы можем загрузить нашу операционную систему.
Если ваша ОС <<32-битная>>, то больше никаких действий по инициализации не требуется.
Однако, в этом режиме вы не можете использовать больше 4 Гбайт памяти,
и ваши регистры имеют ширину в 32 бита.
Если вы хотите использовать больше памяти,
вам необходимо перейти в режим 64-битной адресации, который называется \emph{Long Mode}~\cite{enwiki:longmode}.

Переход в Long Mode может быть осуществлен только из Protected Mode\footnote{
Точнее, так говорит документация.
На самом деле существует способ перейти в Long Mode,
не настраивая перед этим 32-битных сегментов~\cite{osforum:directlongmode}.
Однако этот способ не рекомендуется,
потому что он не позволит обнаружить никаких ошибок, связанных с paging:
в Real Mode невозможно настроить IDT, и поэтому любые прерывания будут приводить к triple fault и перезагрузке.},
поэтому нужно сначала соорудить минимальное окружение в Protected Mode
(в частности GDT и TSS), прежде чем переходить дальше.

Как и с Protected Mode, не существует стандартного способа выйти из Long Mode.
Поэтому нужно завершить все дела с Protected Mode, прежде чем осуществлять переход.
К счастью, большинство возможностей Protected Mode доступны в Long Mode -- 
в частности, <<32-битные>> программы можно запускать из Long Mode,
потому что в GDT для Long Mode есть флаг, который, если установлен,
позволяет исполнять код, написанный для Protected Mode.

Однако есть одно важное ограничение: в Long Mode нельзя использовать
режим под названием \emph{Virtual 8086 Mode}.
Этот режим позволяет исполнять код, написанный для Real Mode,
пока ваша ОС находится в Protected Mode.
Одно из важнейших использований этого режима -- вызов BIOS-функций из ядра вашей ОС;
это необходимо, например, для настройки видео-режима,
потому что многие чипсеты не имеют интерфейса для работы с ними из Protected Mode.
Также, некоторые вендоры используют эту способность для особенных задач:
например, Microsoft использовала Virtual 8086 Mode для загрузки DOS-приложений
из Windows NT
\footnote{Для того, чтобы такой режим работал, нужна программа -- монитор V86,
которая перехватывает прерывания, выполняемые в Virtual 8086 Mode,
и обрабатывает их.
В Windows NT это выполняет программа \code{NTVDM},
и она виртуализирует BIOS-вызовы, переводя их в системные вызовы Windows NT.
Из-за того, что эта схема требует доступа к Virtual 8086 Mode,
этот системный модуль отсутствует на 64-битных версиях Windows}.
Если вам нужно использовать программы, работающие в Real Mode,
в вашей ОС, которая работает в Long Mode, то вам нужно будет использовать
полноценное решение виртуализации: например, DOSBox была создана, чтобы
запускать DOS-игры на современных ОС.

\subsection{Определение 64-битного процессора}

Инструкция \code{CPUID}, которая была введена в Pentium,
позволяет получить информацию о процессоре.
Один из фактов, которые можно получить с помощью этой инструкции,
-- это то, поддерживает ли процессор Long Mode.
Это можно узнать, проверив бит 29 в регистре \code{EDX} после выполнения
инструкции \code{CPUID} с \code{EAX = 0x8000\_0001}.

\begin{minted}{asm}
mov eax, 8000_0001h  ; запросить Extended Processor Info
cpuid

; получить значение, у которого задан бит 29
mov eax, 1   ; установить бит 0
shl eax, 29  ; сдвинуть бит влево на 29 позиций

; проверить, установлен ли бит 29
and eax, edx ; получить бит 29 из edx
cmp eax, 0   ; проверить, равен ли только он 0
jne long_mode_supported ; если нет, то Long Mode поддерживается

hlt  ; если Long Mode не поддерживается, остановиться

long_mode_supported: ...
\end{minted}

\subsection{Включение Long Mode}

Для включения Long Mode нужно выполнить следующие шаги~\cite{web:intel-ia32}:

\begin{enumerate}
    \item Выключить paging, задав значение 0 в бите \code{PG} регистра \code{CR0}.
    \item Включить PAE, задав значение 1 в бите \code{PAE} регистра \code{CR4}.
    \item В регистр \code{CR3} записать адрес таблицы страниц (PML4).
    \item Включить режим Long Mode, задав значение 1 в бите \code{LME} регистра \code{EFER}.
    \item Опционально, включить paging обратно (1 в \code{PG} регистра \code{CR0}).
\end{enumerate}

Начальная таблица страниц должна находиться в первых 4 Гб памяти, потому что
ее инициализация должна проводиться в Protected Mode, и операция \code{MOV} в \code{CR3}
поэтому ограничена 32-битным адресом.
После включения Long Mode можно будет переместить таблицу страниц в любое место памяти.

\section{Заключение}

Процесс загрузки современного компьютера отражает процесс развития его архитектуры.
Архаичные решения, вроде блокировки линии A20 ради совместимости с багами 16-битных приложений,
служат напоминанием о том, как развивались те системы, которые сейчас стали повсеместными.

Эмуляция старых версий процессоров внутри более новых позволяет запускать старое ПО на новом оборудовании (в определенных пределах),
что позволило Intel оставаться самым крупным производителем процессоров на протяжении большинства истории ПК.
Однако поддержка старых версий процессоров внутри новых становится все более затратной,
как для производства этих процессоров, так и для разработки загрузчиков ОС для них.
Из-за этого самые новые компьютеры, использующие UEFI-архитектуру, часто не содержат поддержки 16-битных режимов
и режима BIOS-совместимости.

По мере того, как компьютеры становятся новее и быстрее, такие способы эмуляции становятся все менее полезными;
сейчас большинство задач по работе со старым ПО решаются с помощью программ, которые интерпретируют машинный код
для другой архитектуры и исполняют соответствующие инструкции на текущей архитектуре.
Такие решения называются <<виртуальные машины,>> и они сейчас достигли высокого уровня развития,
благодаря чему все хитрости и особенности более старых версий x86-процессоров становятся более ограничевающими фактором
для разработчиков ПО, чем полезными для обратной совместимости.

Тем не менее, ваш компьютер все еще умеет вести себя как Intel 8086.

\newpage

\section{Список литературы}

% Print bibliography without heading
\printbibliography [heading=none]


\end{document}